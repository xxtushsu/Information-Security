/**
 * File :           stream.c
 * Date :           1 okt, 2020
 * Authors :        Antonin (s3791378), Xiaoyu (s3542807)
 * Context :        2nd exercise of Lab 2 for the course Information Security
 * Description :    This code encodes a stream of bytes with a key using RC4.
 */

#include <stdio.h>
#include <stdlib.h>

#define BYTE_LIMIT 256  // The max value a unsigned byte can represent.

/**
 * This function swaps two bytes a and b.
 * @param a Pointer to the first byte.
 * @param b Pointer to the second byte.
 */
void swap(unsigned char *a, unsigned char *b){
    unsigned char temp = *a;
    *a = *b;
    *b = temp;
}

/**
 * This function reads byte input from stdin until a byte code is read and returns it in a byte array.
 * @param exit The byte code that should terminate the reading of the input when it is read.
 * @param size A pointer to the size of the byte array that is returned.
 * @return An allocated array of bytes.
 */
unsigned char *inputUntil(unsigned char exit, int *size){
    int bytesRead = 0;
    *size = 2;
    unsigned char c, *byteArr = malloc(sizeof(unsigned char) * *size);
    c = getc(stdin);

    while (c != exit){
        byteArr[bytesRead] = c;
        bytesRead++;
        if (bytesRead == *size){
            *size *= 2;
            byteArr = realloc(byteArr, sizeof(unsigned char) * *size);
        }
        c = getc(stdin);;
    }

    *size = bytesRead;
    return byteArr;
}

/**
 * This function initializes the rc4 lookup table for a given key.
 * @param key The key used to generate the table as a byte array.
 * @param keySize The length of the key byte array.
 * @return The lookup table as a byte array size 256 with values from 0-255.
 */
unsigned char *rc4_init(unsigned char *key, int keySize){
    unsigned char *lookupTable = malloc(BYTE_LIMIT * sizeof(unsigned char));

    // initialize lookup table.
    for (int i = 0; i < BYTE_LIMIT; i++){
        lookupTable[i] = i;
    }

    // shuffle the lookup table in pseudo random fashion.
    for (int i = 0, j = 0; i < BYTE_LIMIT; i++){
        j = (j + key[i % keySize] + lookupTable[i]) % BYTE_LIMIT;
        swap(&lookupTable[i], &lookupTable[j]);
    }

    return lookupTable;
}

/**
 * This function encrypts a stream of bytes from stdin.
 * @param lookupTable A lookup table generated by a key.
 */
void rc4_encrypt(unsigned char *lookupTable){
    unsigned char c = getc(stdin);
    int i = 0, j = 0;

    // For safety reasons delay the first byte by 256.
    for (int x = 0; x < BYTE_LIMIT; x++){
        i = (i + 1) % BYTE_LIMIT;
        j = (j + lookupTable[i]) % BYTE_LIMIT;
        swap(&lookupTable[i], &lookupTable[j]);
    }

    // Actually encoding the stream of bytes.
    while(!feof(stdin)){
        i = (i + 1) % BYTE_LIMIT;
        j = (j + lookupTable[i]) % BYTE_LIMIT;
        swap(&lookupTable[i], &lookupTable[j]);
        putc(c ^ lookupTable[(lookupTable[j] + lookupTable[i]) % BYTE_LIMIT], stdout);
        c = getc(stdin);
    }
}

int main(int argc, char **argv) {
    int keyLen;
    unsigned char *key = inputUntil(0xFF, &keyLen);

    unsigned char *lookupTable = rc4_init(key, keyLen);
    rc4_encrypt(lookupTable);

    free(key);
    free(lookupTable);
    return EXIT_SUCCESS;
}